use crate::core::entity_traits::mbid::IsMbid;
use crate::core::entity_traits::vec_from_vec::InnerFrom;
use crate::models::data::listenbrainz::user_listens::UserListens;
use crate::models::data::musicbrainz::mbid::extensions::VecTExt;
use crate::models::radio::RadioConfig;
use crate::utils::playlist::PlaylistStub;
use chrono::prelude::Utc;
use chrono::Duration;
use futures::stream;
use futures::StreamExt;
use rust_decimal::prelude::Decimal;
use rust_decimal::prelude::FromPrimitive;
use std::cmp::Reverse;

pub async fn overdue_radio(
    username: &str,
    token: &str,
    min_listens: Option<u64>,
    cooldown: u64,
    overdue_factor: bool,
    config: RadioConfig,
) -> color_eyre::Result<()> {
    let mut listens = UserListens::get_user_with_refresh(username)
        .await
        .expect("Couldn't fetch the new listens")
        .get_mapped_listens();

    let deadline = Utc::now() - Duration::hours(cooldown as i64);
    let blacklisted_recordings = listens
        .get_listened_after(&deadline)
        .get_listened_recordings_mbids()
        .await
        .unwrap();

    // Filter out all the listens of blacklisted recordings
    listens = listens
        .filter_recordings(&blacklisted_recordings, true, false)
        .await
        .unwrap();

    let mut scores = listens
        .get_listen_rates()
        .await
        .expect("Couldn't calculate the listens rates");

    // Filter minimum
    scores.retain(|rate| rate.1.listen_count() > &min_listens.unwrap_or(3_u64));

    // Sort
    if !overdue_factor {
        scores.sort_by_cached_key(|rate| {
            rate.1.get_estimated_date_of_next_listen(&rate.0) - Utc::now()
        });
    } else {
        scores.sort_by_cached_key(|rate| {
            Reverse(
                Decimal::from_i64(rate.1.get_overdue_by(&rate.0).num_seconds()).unwrap()
                    / Decimal::from_i64(rate.1.get_average_time_between_listens().num_seconds())
                        .unwrap(),
            )
        });
    }

    let scores_as_recording = stream::iter(scores.clone())
        .map(|(_, rate)| async move { rate.recording().get_or_fetch_entity().await })
        .buffered(1);
    let playlist = config.finalize_radio_playlist(scores_as_recording).await?;

    PlaylistStub::new(
        "Radio: Overdue listens".to_string(),
        Some(username.to_string()),
        true,
        playlist.into_mbids().inner_from(),
        Some(
            "Automatically generated by: https://github.com/RustyNova016/listenbrainz-cli-tools"
                .to_string(),
        ),
    )
    .send(token)
    .await?;

    Ok(())
}
