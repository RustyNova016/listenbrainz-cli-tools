use core::pin::Pin;

use chrono::Duration;
use futures::{stream, StreamExt};

use crate::datastructures::entity_with_listens::recording_with_listens::RecordingWithListens;
use crate::datastructures::radio::collector::RadioCollector;
use crate::datastructures::radio::filters::cooldown::cooldown_filter;
use crate::datastructures::radio::filters::min_listens::min_listen_filter;
use crate::datastructures::radio::filters::timeouts::timeout_filter;
use crate::datastructures::radio::seeders::listens::ListenSeeder;
use crate::datastructures::radio::sorters::overdue::overdue_factor_sorter;
use crate::datastructures::radio::sorters::overdue::overdue_factor_sorter_cumulative;
use crate::datastructures::radio::sorters::overdue::overdue_sorter;
use crate::models::playlist_stub::PlaylistStub;
use crate::utils::println_cli;

//TODO: Refactor Radios params into structs
#[expect(clippy::too_many_arguments)]
pub async fn overdue_radio(
    conn: &mut sqlx::SqliteConnection,
    seeder: ListenSeeder,
    token: &str,
    min_listens: Option<u64>,
    cooldown: u64,
    overdue_factor: bool,
    collector: RadioCollector,
    at_listening_time: bool,
) -> color_eyre::Result<()> {
    let username = seeder.username().clone();

    println_cli("[Seeding] Getting listens");
    let recordings = seeder.seed(conn).await.expect("Couldn't find seed listens");

    println_cli("[Filter] Filtering minimum listen count");
    let recordings = min_listen_filter(recordings.into_values_stream(), min_listens.unwrap_or(3));

    println_cli("[Filter] Filtering listen cooldown");
    let recordings = cooldown_filter(recordings, Duration::hours(cooldown as i64));

    println_cli("[Filter] Filtering listen timeouts");
    let recordings = timeout_filter(recordings);

    let recordings = if !overdue_factor {
        println_cli("[Sorting] Sorting listen by overdue duration");
        Box::pin(stream::iter(overdue_sorter(recordings.collect().await))) as Pin<Box<dyn futures::Stream<Item = RecordingWithListens>>>
    } else if !at_listening_time {
        println_cli("[Sorting] Sorting listen by overdue factor");
        Box::pin(stream::iter(overdue_factor_sorter(
            recordings.collect().await,
        ))) as Pin<Box<dyn futures::Stream<Item = RecordingWithListens>>>
    } else {
        println_cli("[Sorting] Sorting listen by overdue factor at listen time");
        Box::pin(overdue_factor_sorter_cumulative(recordings.collect().await))
    };

    println_cli("[Finalising] Creating radio playlist");
    let collected = collector
        .collect(recordings.map(|r| r.recording().clone()))
        .await;

    println_cli("[Sending] Sending radio playlist to listenbrainz");
    PlaylistStub::new(
        "Radio: Overdue listens".to_string(),
        Some(username.to_string()),
        true,
        collected.into_iter().map(|r| r.mbid).collect(),
        Some("Automatically generated by: https://github.com/RustyNova016/Alistral".to_string()),
    )
    .send(token)
    .await?;

    Ok(())
}

// #[tokio::test]
// #[serial_test::serial]
// async fn overdue_by() {
//     use crate::datastructures::radio::collector::RadioCollectorBuilder;
//     overdue_radio(
//         "RustyNova",
//         "t",
//         None,
//         0,
//         false,
//         RadioCollectorBuilder::default()
//             .count_default()
//             .duration_default()
//             .build(),
//             true
//     )
//     .await
//     .unwrap();
// }
